---
- name: Provisioning a node
  hosts: charon_test
  gather_facts: false
  become: true

  vars:
    target_k3s_version: "v1.28.7+k3s1"
    k3s_namespace: charon
    mimir_url: "http://mimir-nginx.{{ k3s_namespace }}.svc:80/api/v1/push"
    scrape_interval: 15s
    k3s_cluster_cidr: "10.31.0.0/16"
    k3s_service_cidr: "10.32.0.0/16"

  tasks:
  # NOTE: this is only for Chameleon machines as their OS images block ingress/egress by default
  - name: Add Kubernetes in the firewall
    ansible.builtin.command: firewall-cmd --zone=trusted --add-source "{{ k3s_cluster_cidr }}" --add-source "{{ k3s_service_cidr }}"
    ignore_errors: true
      
  # TODO: we would want to check if the host OS is Debian/Ubuntu
  - name: Install base packages
    ansible.builtin.apt:
      pkg:
      - curl
      - python3-pip
      - apt-transport-https
      - net-tools
      # add other packages here
  
  - name: Upgrade pip
    ansible.builtin.pip:
      name: pip
      state: latest
  
  - name: Install Python packages
    ansible.builtin.pip:
      name: kubernetes
      state: present

  # TODO: we may want to skip this if already exists
  - name: Get k3s installed version
    ansible.builtin.command: k3s --version
    register: k3s_version_output
    changed_when: false
    ignore_errors: true

  - name: Set k3s installed version
    when: k3s_version_output.rc == 0
    ansible.builtin.set_fact:
      installed_k3s_version: "{{ k3s_version_output.stdout_lines[0].split(' ')[2] }}"

  - name: Install Kubernetes (k3s)
    ansible.builtin.shell: curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION="{{ target_k3s_version }}" K3S_CLUSTER_SECRET=4tX0DUZ0uQknRtVUAKjt INSTALL_K3S_EXEC="server --cluster-cidr {{ k3s_cluster_cidr }} --service-cidr {{ k3s_service_cidr }}" sh -
    args:
      executable: /bin/bash
    when: k3s_version_output.rc != 0 or installed_k3s_version is version(target_k3s_version, '<')
  
  - name: Install Helm chart
    ansible.builtin.shell: curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    args:
      executable: /bin/bash
  
  - name: Ensure k3s systemd is in running state
    service:
      name: k3s
      state: started
    register: k3sDetails
    until: k3sDetails.status.ActiveState == "active"
    retries: 10
    delay: 5

  - name: Create directory .kube
    when: ansible_user is defined
    ansible.builtin.file:
      path: ~{{ ansible_user }}/.kube
      state: directory
      owner: "{{ ansible_user }}"
      mode: "u=rwx,g=rx,o="

  - name: Copy config file to user home directory
    when: ansible_user is defined
    ansible.builtin.copy:
      src: /etc/rancher/k3s/k3s.yaml
      dest: ~{{ ansible_user }}/.kube/config
      remote_src: true
      owner: "{{ ansible_user }}"
      mode: "u=rw,g=,o="

  - name: Configure default KUBECONFIG for user
    when: ansible_user is defined
    ansible.builtin.lineinfile:
      path: ~{{ ansible_user }}/.bashrc
      regexp: 'export KUBECONFIG=~/.kube/config'
      line: 'export KUBECONFIG=~/.kube/config # Added by k3s-ansible'
      state: present

  - name: Create our namespace in Kubernetes
    kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      name: "{{ k3s_namespace }}"
      api_version: v1
      kind: Namespace
      state: present

  - name: Install Grafana CRDs
    kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      state: present
      src: "{{ item }}"
    with_items:
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.coreos.com_podmonitors.yaml
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.coreos.com_probes.yaml
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.coreos.com_servicemonitors.yaml
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.grafana.com_grafanaagents.yaml
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.grafana.com_integrations.yaml
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.grafana.com_logsinstances.yaml
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.grafana.com_metricsinstances.yaml
    - https://raw.githubusercontent.com/grafana/agent/main/operations/agent-static-operator/crds/monitoring.grafana.com_podlogs.yaml
    ignore_errors: true
  
  - name: Add grafana mimir to Helm chart
    kubernetes.core.helm_repository:
      name: grafana
      repo_url: https://grafana.github.io/helm-charts

  - name: Deploy Grafana mimir in Kubernetes
    kubernetes.core.helm:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      name: mimir
      namespace: "{{ k3s_namespace }}"
      chart_ref: grafana/mimir-distributed
      chart_version: 5.2.1

  - name: Check if Nvidia GPU is available
    ansible.builtin.command: nvidia-smi --list-gpus
    register: list_of_nvidia_gpus
    changed_when: false
    ignore_errors: true

  - name: Set a number of available Nvidia GPUs
    when: list_of_nvidia_gpus.rc == 0
    ansible.builtin.set_fact:
      number_of_available_nvidia_gpu: "{{ list_of_nvidia_gpus.stdout_lines | length }}"

  - name: Install Nvidia container toolkit
    when: list_of_nvidia_gpus.rc == 0 and number_of_available_nvidia_gpu | int >= 1
    ansible.builtin.apt:
      pkg:
      - nvidia-container-toolkit

  - name: Add Nvidia DCGM to Helm chart
    when: list_of_nvidia_gpus.rc == 0 and number_of_available_nvidia_gpu | int >= 1
    kubernetes.core.helm_repository:
      name: gpu-helm-charts
      repo_url: https://nvidia.github.io/dcgm-exporter/helm-charts

  # - name: Check number of GPUs
  #   debug:
  #     msg: "{{ number_of_available_nvidia_gpu }}"

  - name: Deploy Nvidia DCGM in Kubernetes
    when: list_of_nvidia_gpus.rc == 0 and number_of_available_nvidia_gpu | int >= 1
    kubernetes.core.helm:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      name: nvidia-dcgm
      namespace: "{{ k3s_namespace }}"
      chart_ref: gpu-helm-charts/dcgm-exporter
      set_values:
      - value: runtimeClassName=nvidia
        value_type: string

  - name: Create ConfigMap for Grafana dashboard
    kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      state: present
      namespace: "{{ k3s_namespace }}"
      definition: "{{ lookup('template', 'kubernetes/grafana-config-datasources.yaml.j2') | from_yaml_all }}"

  - name: Deploy Grafana dashboard
    kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      state: present
      namespace: "{{ k3s_namespace }}"
      definition: "{{ lookup('file', 'kubernetes/grafana.yaml') | from_yaml_all }}"

  - name: Install Grafana operator
    kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      state: present
      namespace: "{{ k3s_namespace }}"
      definition: "{{ lookup('template', 'kubernetes/grafana-operator.yaml.j2') | from_yaml_all }}"

  - name: Install Grafana agent
    kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      state: present
      namespace: "{{ k3s_namespace }}"
      definition: "{{ lookup('template', 'kubernetes/grafana-agent.yaml.j2') | from_yaml_all }}"

  - name: Deploy Grafana operator scrapers
    kubernetes.core.k8s:
      kubeconfig: /etc/rancher/k3s/k3s.yaml
      state: present
      namespace: "{{ k3s_namespace }}"
      definition: "{{ lookup('template', 'kubernetes/grafana-operator-scrape.yaml.j2') | from_yaml_all }}"

  - name: Create directory for dependencies
    when: ansible_user is defined
    become: false
    ansible.builtin.file:
      path: ~{{ ansible_user }}/dependencies
      state: directory
      owner: "{{ ansible_user }}"
      mode: "u=rwx,g=rx,o="

  - name: Add the geopm PPA repository
    apt_repository:
      repo: 'ppa:geopm/release'
      state: present

  - name: Update the apt package list
    ansible.builtin.apt:
      update_cache: yes

  - name: Install apt dependencies
    ansible.builtin.apt:
      name:
        - gcc
        - make
        - autoconf
        - automake
        - libtool
        - pkg-config
        - libzmq3-dev
        - libzmq5
        - libczmq-dev
        - libczmq4
        - libprotobuf-c-dev
        - protobuf-c-compiler
        - libjansson-dev
        - libjansson4
        - check
        - libhwloc-dev
        - libpapi-dev
        - mpich
        - libomp-dev
        - libomp5
        - geopm-service
        - libgeopmd-dev
        - libgeopmd2
        - python3-geopmdpy
      state: present
      update_cache: yes

  - name: Clone bats
    ansible.builtin.git:
      repo: 'https://github.com/bats-core/bats-core.git'
      dest: ~{{ ansible_user }}/dependencies/bats
      version: v1.9.0

  - name: Clone libnrm
    ansible.builtin.git:
      repo: 'https://github.com/anlsys/libnrm.git'
      dest: ~{{ ansible_user }}/dependencies/libnrm
      version: feature/prometheus-exporter
  
  - name: Install bats
    ansible.builtin.shell: |
      cd ~{{ ansible_user }}/dependencies/bats
      ./install.sh /usr

  - name: Install libnrm
    ansible.builtin.shell: |
      cd ~{{ ansible_user }}/dependencies/libnrm
      ./autogen.sh
      ./configure --prefix=/usr --with-python --with-geopm
      make -j
      make install
      
  - name: Create systemd service unit file for nrmd
    ansible.builtin.copy:
      dest: /etc/systemd/system/nrmd.service
      content: |
        [Unit]
        Description=NRMD Service

        [Service]
        Type=simple
        ExecStart=/usr/bin/nrmd
        Restart=always
        User=cc
        StandardOutput=journal
        StandardError=journal

        [Install]
        WantedBy=multi-user.target

  - name: Create systemd service unit file for nrm-geopm
    ansible.builtin.copy:
      dest: /etc/systemd/system/nrm-geopm.service
      content: |
        [Unit]
        Description=NRMD Service

        [Service]
        Type=simple
        
        ExecStart=/usr/bin/nrm-geopm -e CPU_ENERGY
        Restart=always
        User=cc
        StandardOutput=journal
        StandardError=journal

        [Install]
        WantedBy=multi-user.target

  - name: Reload systemd to recognize the new service
    ansible.builtin.command: systemctl daemon-reload

  - name: Start nrmd service
    ansible.builtin.systemd:
      name: nrmd
      state: started

  - name: Provision geopm
    ansible.builtin.shell: |
      sudo modprobe msr
      sudo systemctl restart geopm.service 
      geopmaccess -a > /tmp/allaccess
      geopmaccess -w -c < /tmp/allaccess
      geopmaccess -w < /tmp/allaccess


  - name: Start nrmd service
    ansible.builtin.systemd:
      name: nrm-geopm
      state: started

  - name: Configure PYTHONPATH for user
    ansible.builtin.lineinfile:
      path: ~{{ ansible_user }}/.bashrc
      regexp: 'export PYTHONPATH=/usr/lib/python3.10/site-packages:$PYTHONPATH'
      line: 'export PYTHONPATH=/usr/lib/python3.10/site-packages:$PYTHONPATH # Added by ansible'
      state: present
